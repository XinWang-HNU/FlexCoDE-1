% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/basicFunctions (CÃ³pia em conflito de rizbicki-Gazelle-Professional 2017-10-04).R, R/basicFunctions.R
\name{predict.FlexCoDE}
\alias{predict.FlexCoDE}
\title{Evaluates the estimated  density of new observations (testing points) of a "FlexCoDE" object}
\usage{
predict.FlexCoDE(obj, xNew, B = 1000, predictionBandProb = FALSE,
  process = TRUE)

predict.FlexCoDE(obj, xNew, B = 1000, predictionBandProb = FALSE,
  process = TRUE)
}
\arguments{
\item{xNew}{Matrix with nTest rows and same number of columns as xTrain, containing x's for which the estimates are desired.}

\item{B}{Number of point where f(z|x) will be evaluated (on the z scale). This will be equally spaced between zMin and zMax}

\item{predictionBandProb}{Either a number indicating the probability for the highest predictive density region desired  or FALSE if bands are not desired. Default is FALSE}

\item{objectCDE}{Object of the class "FlexCoDE", typically fitted used \code{\link{fitFlexCoDE}} beforehand}

\item{objectCDE}{Object of the class "FlexCoDE", typically fitted used \code{\link{fitFlexCoDE}} beforehand}

\item{xNew}{Matrix with nTest rows and same number of columns as xTrain, containing x's for which the estimates are desired.}

\item{B}{Number of point where f(z|x) will be evaluated (on the z scale). This will be equally spaced between zMin and zMax}

\item{predictionBandProb}{Either a number indicating the probability for the highest predictive density region desired  or FALSE if bands are not desired. Default is FALSE}
}
\value{
The return value is an object with the following components
\item{z}{Points where the density was evaluate}
\item{CDE}{Matrix with value of the density at points z. Each row corresponds to a different observation x (i-th row of CDE corresponds to i-th row of xTest).}
\item{th}{(If predictionBandProb is not FALSE) Threshold values for each estimated density. The region where estimated densities are above these values have the approximate coverage probability desired. See  \code{\link{plot.FlexCoDE}} for ploting these regions.}

The return value is an object with the following components
\item{z}{Points where the density was evaluate}
\item{CDE}{Matrix with value of the density at points z. Each row corresponds to a different observation x (i-th row of CDE corresponds to i-th row of xTest).}
\item{th}{(If predictionBandProb is not FALSE) Threshold values for each estimated density. The region where estimated densities are above these values have the approximate coverage probability desired. See  \code{\link{plot.FlexCoDE}} for ploting these regions.}
}
\description{
Evaluates the estimated  density of new observations (testing points) of a "FlexCoDE" object

Evaluates the estimated  density of new observations (testing points) of a "FlexCoDE" object
}
\examples{
set.seed(400)

# generate data
n=1000
d=10
data=matrix(NA,n,d+1)
data[,1:d]=matrix(rnorm(n*d),n,d)
# generate response from a mixture
data[,d+1]=data[,1]+rnorm(n,0,0.1)


# determine sample sizes
nTrain=round(0.7*n)
nValidation=round(0.25*n)
nTest=n-nTrain-nValidation

# split data
randomIndex=sample(1:n)
xTrain=data[randomIndex[1:nTrain],1:d]
xValidation=data[randomIndex[(nTrain+1):(nTrain+nValidation)],1:d]
xTest=data[randomIndex[(nTrain+nValidation+1):n],1:d]
zTrain=data[randomIndex[1:nTrain],d+1]
zValidation=data[randomIndex[(nTrain+1):(nTrain+nValidation)],d+1]
zTest=data[randomIndex[(nTrain+nValidation+1):n],d+1]


############################################################
# fit SpAM estimator (appropriate for sparse structure); we change
######## default value of tuning parameters
############################################################
fit=fitFlexCoDE(xTrain,zTrain,xValidation,zValidation,xTest,zTest,
                nIMax = 50,regressionFunction = regressionFunction.SpAM,
                regressionFunction.extra=list(sVec=round(seq(1,20,length.out = 5))))

# Plot estimated curves evaluates on new test points, and
# compare with true conditional density
predictedValues=predict(fit,xTest,B=500)
plot(predictedValues$z,predictedValues$CDE[1,])
lines(predictedValues$z,dnorm(predictedValues$z,xTest[1,1],0.1),col=2)


set.seed(400)

# generate data
n=1000
d=10
data=matrix(NA,n,d+1)
data[,1:d]=matrix(rnorm(n*d),n,d)
# generate response from a mixture
data[,d+1]=data[,1]+rnorm(n,0,0.1)


# determine sample sizes
nTrain=round(0.7*n)
nValidation=round(0.25*n)
nTest=n-nTrain-nValidation

# split data
randomIndex=sample(1:n)
xTrain=data[randomIndex[1:nTrain],1:d]
xValidation=data[randomIndex[(nTrain+1):(nTrain+nValidation)],1:d]
xTest=data[randomIndex[(nTrain+nValidation+1):n],1:d]
zTrain=data[randomIndex[1:nTrain],d+1]
zValidation=data[randomIndex[(nTrain+1):(nTrain+nValidation)],d+1]
zTest=data[randomIndex[(nTrain+nValidation+1):n],d+1]


############################################################
# fit SpAM estimator (appropriate for sparse structure); we change
######## default value of tuning parameters
############################################################
fit=fitFlexCoDE(xTrain,zTrain,xValidation,zValidation,xTest,zTest,
                nIMax = 50,regressionFunction = regressionFunction.SpAM,
                regressionFunction.extra=list(sVec=round(seq(1,20,length.out = 5))))

# Plot estimated curves evaluates on new test points, and
# compare with true conditional density
predictedValues=predict(fit,xTest,B=500)
plot(predictedValues$z,predictedValues$CDE[1,])
lines(predictedValues$z,dnorm(predictedValues$z,xTest[1,1],0.1),col=2)


}

